#ifndef TREE_HPP
#define TREE_HPP
#include <vector>

struct node {
 //int val;
 

 //????????????????????????????????????????????????????????????????????
 //頂点修復用に最初は，どんな配列で，行ったのかを持つ必要があり，次のDFSからは，親の頂点情報と自分の現在の頂点とを合わせて情報を復元できそう
 //std::vector< int > V; 
 //???????????????????????????????????????????????????????????????????

 std::vector< node* > children;
 std::vector< int > path; // children[i]へは，path[i]を追加したことど同じ


 node(){}
 //node(int val):val(val){}

 int size() { return children.size() ; }
 bool leaf() { return children.size() == 0  ? true : false; }
 //void print();
 void push( int v ){
  node* a = new node;
  //a->val = v;
  path.push_back( v );
  children.push_back( a );
 }
 void push( node* a , int v){
  path.push_back( v );
  children.push_back( a );
 }
};

struct tree{
 node root;
 tree(){}
 void dfs(node& a);
};

#endif
